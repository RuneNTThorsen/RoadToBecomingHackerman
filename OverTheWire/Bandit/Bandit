Level 0:
-----------
    In Bandit0 you are supposed to connect to bandit.labs.overthewire.org using ssh on port 2220. The username is bandit0 and so is the password. Provided one has ssh installed, this is done in the terminal with
        $ ssh bandit0@bandit.labs.overthewire.org -p 2220.
    Notice the flag "-p" and the number "2220". The flag is used to tell ssh that a specific port is to be used and the subsequent number is the port to be used.    
    After this is done, one is asked for the password, which as previously mentioned is "bandit0". Typing this in and hitting Enter then grants access.


Level 0 -> Level 1:
----------------------
    Once in you have to find the password for the next level. That is the password for bandit1. It is allegedly in the file "readme" in the directory that you are in, once bandit0 has been completed. To check this use
        $ ls
    and the file "readme" is listed. Use
        $ cat readme
    to print out the contents of the "readme"-file. The password is then printed out to your terminal. The contents read
        NH2SXQwcBdpmTEzi3bvBHMM9H66vVXjL.

    In general for the bandit levels, level <x> is accessed using
        $ bandit<x>@bandit.labs.overthewire.org -p 2220
    and the password from the previous level.


Level 1 -> Level 2:
----------------------
    Here the password for the next level is in a file called "-".
        $ cat '
    does not work - probably because the filename is a special character. The same goes for
        $ cat "-".
    However, the command
        $ cat ./-
    does work, since the whole path to the file is being specified, yielding the password
        rRGizSaX8Mk1RTb1CNQoXTcYZWU6lgzi.


Level 2 -> Level 3:
----------------------
    The password for level 3 is in a file called "spaces in this filename". Under normal circumstances the Linux terminal cannot handle spaces in a name, since it then assumes that the thing after the space is a new command entirely. The solution is then to put the file name in quotation marks:
        $ cat "spaces in this filename"
    then yields the password
        aBZ0W5EmUfAf7kHTQeOwd8bauFJ2lAiG.


Level 3 -> Level 4:
----------------------
    This time the password is in a hidden file inside the folder "inhere". Usually, one would use
        $ ls
    to list the files in a directory, but using this inside the "inhere" folder yields nothing as expected, since the file that is looked for is a hidden file. Therefore
        $ ls -a
    is used, since the flag "-a" makes ls also list hidden files, which can be recognised by having their filename start with "." (a full stop). (obviously, one would first have to change directory to the aforementioned folder using
        $ cd inhere.
    "cd" is the Linux command used to change directory. It is also a shorthand for exactly that)
    The hidden file that is being looked for is listed and is called ".hidden". Using
        $ cat .hidden
    then prints out the password
        2EW7BBsr6aMMoJ2HjW067dm8EgX26xNe


Level 4 -> Level 5:
----------------------
    The file with the password is again inside a folder called "inhere". Allegedly there is only one human-readable file in this directory, which is also the one that contains the password for the next level. Trying to read the other files in the directory does something weird with the terminal, but this can easily be undone using
        $ reset
    but is not strictly necessary. Through trial and error the file "-file07" seems to be the one that is sought after. Using
        $ cat ./-file07
    then yields the password
        lrIWWI6bB37kxfiCQZqUdOIYfr6eEeqR.


Level 5 -> Level 6:
----------------------
    This time the file containing the password is somewhere inside the folder "inhere" again. Allegedly the file is human-readable, has size 1033 bytes and is not an executable file. Something worth of notice is that the folder "inhere" contains a lot of subfolders called "maybehere00"..."maybehere19".
        $ find . -type f ! -executable -size 1033c
    should find the wanted file in question. The "find" function is the native Linux function that finds a specific file - or at least the ones that matches the parameters that have been specified. "." tells "find" that the search is to start in the current folder, "-type" is a flag that is followed by some parameter that specifies which type of file that is being looked for (in this case "f" for a regular file). "!" is used in order to negate the following expression, "-executable" which specifies that the file in quetion is an executable file (so "! -executable" means that the file in question is not an executable). "-size" is used to specify the size of the file in question and is followed by the parameter "1033c", which specifies that the wanted file is of size 1033 bytes ("c" for bytes).
    The only file that lives up to all the specifications above is the file
        ./maybehere07/.file2,
    so using
        $ cat maybehere07/.file2
    (or if the directory has not been changed since connecting:
        $ cat inhere/maybehere07/.file2)
    then yields the password
        P4L4vucdmLnm8I7Vl7jG1ApGSfjYKqJU.
    (Do however notice, the file contains a lot of whitespace.)


Level 6 -> Level 7:
----------------------
    The only info given about the file containing the password now is that it is stored somewhere on the ssh server, is owned by the user "bandit7", is owned by the group "bandit6" and has size 33 bytes. First of all, let's change directory to the root folder of the server using
        $ cd /.
    Now the command
        $ find . -size 33c -user bandit7 -group bandit6
    can be used and it gives a large and unmanageable list of files, most of which has "Permission denied" written next to them.
    The "-user" flag is given above and is used to specify the user that owns the file being searched for. It is used with the parameter "bandit7", meaning that the file being searched for is owned by the user "bandit7". Likewise the flag "-group" specifies the group that own the file and is used with the parameter "bandit6" to signify, that the group "bandit6" owns the file.
    The problem of making this long list of found files a bit more manageable is done by taking all the files for which permission is denied and sorting them out of the results. The "Permission denied" comes because of a standard error code - more specifically error code 2. By appending "2>dev/null", all results that are returned with standard error code 2 is sent to dev/null (aka. not shown). Thus the file in question is found using
        $ find . -size 33c -user bandit7 -group bandit6 2>/dev/null
    which yields the file
        ./var/lib/dpkg/info/bandit7.password.
    Now
        $ cat var/lib/dpkg/info/bandit7.password
    yields the password
        z7WtoNQU2XfjmMtWA8u5rN4vzqu4v99S.


Level 7 -> Level 8:
----------------------
    This time the password is stored inside the file "data.txt" next to the word "millionth".
        $ cat data.txt
    gives a large and unmanageable list of word and possible passwords next to them. One thing of note is that each and every word- and possible password combination ends with a newline character. This means that what is sought is actually just a specific line in the file.
        $ grep -F millionth data.txt
    can then be used. "grep" is a native Linux command that is used to find a specific line of text in a given file and print it to the terminal. The flag "-F" is used to signify that a specific word is sought (here "word" actually just means a fixed string) and so using it with the parameter "millionth" specifies that the line sought has the word "millionth" in it. As a second argument for grep, the file that is to be searched is specified here; "data.txt". The returned line of text is then
        millionth	TESKZC0XvTetK0S9xNwm25STk5iWrBvP
    from which it can be seen that the password for the next level is
        TESKZC0XvTetK0S9xNwm25STk5iWrBvP.


Levle 8 -> Level 9:
----------------------
    In this level the password is again inside a file called "data.txt". It is stored as the only line in this file that is not repeated.
        $ cat data.txt
    shows that the file contains a lot of lines of potential passwords. Again this is quite unmanageable. The command
        $ uniq -u data.txt
    gives the same output. The "uniq" command is used to filter adjacent matching lines from the input, the "-u" flag specifies that unique lines are to be considered and the second argument is just the file that is to be searched. In order to solve this challenge, the lines need to be read, sorted and then input into "uniq -u". This is done using
        $ cat data.txt | sort | uniq -u.
    "cat" first reads the file, then the lines are sorted using the command "sort" and then the wanted line is found as described above. The vertical lines in this command terminal input is used to take the output of the command on the left and input it into the command on the right. This works because all the lines that are repeated are now adjacent, yielding the line
        EN632PlfYiZbn3PhVK3XOGSlNInNE00t
    which must then be the password that is sought after.


Level 9 -> Level 10:
-----------------------
    The password for this level is again contained in a file called "data.txt". The line with the password is one of the few lines that are human-readable and is preceded by several equal signs. It is of noteworthy importance that the file contains more lines than is feasible to manually search through. Trying
        $ grep === data.txt
    yields
        grep: data.txt: binary file matches,
    so the file is not just a file of text containing several lines, but is a binary file. Here "grep" is used with the first argument of "===", so as to make sure that only lines containing at least 3 equal signs are matched and printed out to the terminal.
        $ strings data.txt
    is the command used to print all ASCII strings in the file, so
        $ string data.txt | grep ===
    is used to take these strings and sent them over to the previously used "grep" command, which should be able to find the line in question. The output is
        x]T========== theG)"
        ========== passwordk^
        ========== is
        ========== G7w8LIi6J3kTb8A7j9LgrywtEUlyyp6s
    and the password can then be read from this as
        G7w8LIi6J3kTb8A7j9LgrywtEUlyyp6s.


Level 10 -> Level 11
-----------------------
    Again the password is inside the file "data.txt", but this time the file is encoded in base 64.
        $ base64 -d data.txt
    is the command to use. "base64" is the command used to do stuff with base 64 numbers, the flag "-d" is used to specify that decoding is wanted and the second argument is just the file that contains what is to be decoded. Using the command above gives
        The password is 6zPeziLdR2RKNdNYFNb6nVCKzphlXHBM
    and so the password is then
        6zPeziLdR2RKNdNYFNb6nVCKzphlXHBM.


Level 11 -> Level 12
-----------------------
    Again the password is inside a file called "data.txt", but this time all of the letters are rotated by 13. This means that the cryptosystem Rot13 has been used (https://en.wikipedia.org/wiki/ROT13) on the letters - which is actually just a special case of the Caesar Cipher using 13 as a key (https://en.wikipedia.org/wiki/Caesar_cipher).
        $ cat data.txt
    gives
        Gur cnffjbeq vf WIAOOSFzMjXXBC0KoSKBbJ8puQm5lIEi.
    Decoding could be done by hand and it is also not hard to implement a small script that could do the decoding. I took the easy route and used an online tool (https://www.dcode.fr/rot-13-cipher) to decode yielding
        The password is JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv
    from which the password can be seen to be
        JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv.

    Okay, I actually did it properly and made a small script that does the decrypting (and encrypting). It is called caesar.py and is used by doing
        python caesar.py "Gur cnffjbeq vf WIAOOSFzMjXXBC0KoSKBbJ8puQm5lIEi" 13 d
    and returns
        The password is JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv.


Level 12 -> Level 13
-----------------------
    The password is once again in a file called "data.txt". This file is a so-called hexdump. It is suggeested that one creates a folder inside of the /tmp folder, copy the file into there and rename it. At each level, some hints are given as to which topics one might look into. One of these is "xxd". This is used to make a hexdump or do the reverse. The "-r" flag is used for reversing. So start by making a directory and moving the file as instructed:
        $ mkdir /tmp/<your-name>
        $ cp data.txt /tmp/<your-name>/data.txt
    and changing to this directory
        $ cd /tmp/<your-name>
    Now let's try reversing and saving whatever gets reversed.
        $ cat data.txt | xxd -r > data
    Another hint is the command "file"; used to determine the file type of a file.
        $ file data
    gives
        data: gzip compressed data, was "data2.bin", last modified: Thu Oct  5 06:19:20 2023, max compression, from Unix, original size modulo 2^32 573.
    Supposing that it is then a ".gz"-file, the file is then renamed as such:
        $ mv data data2.gz
    "gzip" is also a linux command that can be used to compress/decompress files. Decompression is done using the "-d"-flag.
        $ gzip -d data2.gz
    then decompresses and saves the decompressed file as "data2".
        $ file data2
    gives
        data2: bzip2 compressed data, block size = 900k.
    "bzip2" is another file compression/decompression program. The file ending this time is ".bz2".
        $ mv data2 data3.bz2
        $ bzip2 -d data3.bz2
    then gives the file
        data3.
    Using
        $ file data3
    gives
        data3: gzip compressed data, was "data4.bin", last modified: Thu Oct  5 06:19:20 2023, max compression, from Unix, original size modulo 2^32 20480
    and so we repeat the process for a gzip archive again.
        $ file data4
    now gives
        data4: POSIX tar archive (GNU).
    "tar" is another linux command used to make archives.
        $ tar -xvf data5
    then makes the file "data5.bin". The flags "x", "v" and "f" specifies extraction, verbose and file respectively. This is then renamed to "data6.bin" and this file gives the same output again, so unpacking is done again. It seems that renaming and unpacking and seeng what the file contents are has to be done a few times. I have already shown how the tools used. Unless something new comes up, I will just state here, that decompressing and unpacking is done until i reach the end.
    Finally after going through the steps over and over, a "data9" is reached, that is ASCII text.
        $ cat data9
    then gives
        The password is wbWdlBxEir4CaE8LaPhauuOo6pwRmrDw
    from which it can be seen that the password is
        wbWdlBxEir4CaE8LaPhauuOo6pwRmrDw.

    It was suggested to me, that binwalk might have been able to do this task more easily. Perhaps. I think learning about tar, bzip2 and gzip is good though and I doubt, I would have permission to install binwalk on the machine that I am connected to through ssh. The contents of the original data might be copied to my own machine though, but this is not a route that I will explore.



Level 13 -> Level 14
-----------------------
    The password for the next level is stored in /etc/bandit_pass/bandit14. It can only be read by the user bandit14 though. As for this level, one does not get a new password, but instead a private ssh-key (in the home folder - called "sshkey.private"), which will be used to log in to the next level. A hint is given: localhost is a hostname that refers to the machine you are working on.
        $ ls
    gives
        sshkey.private.
        $ cat sshkey.private
    then prints out the ssh-key. It is an RSA key. That is pretty standard. It is then copied into a file "bandit14" in the ~/.ssh directory. In this directory there is also a "config"-file. The key has to be added to this.The following then has to be added to this file:
        Host *.labs.overthewire.org
            user bandit14
            IdentityFile ~/.ssh/bandit14
    and ownership has to be taken of the file:
        $ chown 600 ~/bandit14
    and the key can now be used to log in to the bandit 14 user (the terminal program maybe has to be restarted and the above command maybe has to be done using super user privileges).
        $ cat /etc/bandit_pass/bandit14
    now gives
        fGrHPx402xGC7U7rXKDaxiWFTOiF0ENq
    which must then be the password for the next level.
    The changes made to the config file can then be commented out using "#":
        #Host *.labs.overthewire.org
            #user bandit14
            #IdentityFile ~/.ssh/bandit14
    and they shouldn't be used in the future then.
    Now using
        $ ssh bandit14@bandit.labs.overthewire.org -p 2220
    one is then asked for a password. Using the above mentioned password works.


Level 14 -> Level 15
-----------------------
    The password for the next level can be retrieved by submitting the password of the current level to port 30000 on localhost.
    One of the hints given is "nc", which is short for "netcat". This is a program that is used to establish network connections using TCP or UDP. A simple one-liner for this challenge would then be
        $ echo fGrHPx402xGC7U7rXKDaxiWFTOiF0ENq | nc localhost 30000
    but one can also use
        $ nc localhost 30000
    followed by typing (or copy/pasting) in the password from the previous level before terminating the program using Ctrl+c.
    The "nc" command is followed by the target machine that is to be connected with (n this case "localhost") and after that any potential port that is to be used (in this case "30000").
    Anyway,  in both cases, one gets returned the following:
        Correct!
        jN2kgmIXJ6fShzhT2avhotn4Zcka6tnt
    and one will thus have the password for the next level.


Level 15 -> Level 16
-----------------------
    The password for the next level can be retrieved by submitting the password of the current level to port 30001 on localhost using SSL encryption.
    There are 2 ways of solving this challenge, as far as I see. One hint given for the challenge is "nmap" which is a program that when installed also automatically installs the other program "ncat"(?) (seems to be so at least on Ubuntu). "ncat" is essentially netcat, but expanded upon. One can then open the SSL-connection by providing the "--ssl" flag as such:
        $ ncat --ssl localhost 30001
    get an open connection and write in the password and hitting Enter, sending it off and receiving back
        Correct!
        JQttfApK4SeyHwDlI9SXGR50qclOAil1
    before using Ctrl+c to close the connection again.
    The other hint is "openssl" and "s_client". The connection can also be opened using
        $ openssl s_client -connect localhost:30001
    after which a read block can be typed into. Typing (or copy/pasting) in the password and hitting Enter then prints out
        Correct!
        JQttfApK4SeyHwDlI9SXGR50qclOAil1
    and once again the password is uncovered.
    Openssl is ayet another program and "s_client" seems to be the argument to make it connect as an SSL-client. The "-connect" flag is self-explanatory (and seems to belong to the "s_client" argument(?)). This is followed by the specified host-machine ("localhost") a colon and the port to connect to ("30001").
    In either case, the password for the next level must be
        JQttfApK4SeyHwDlI9SXGR50qclOAil1.


Level 16 -> Level 17
-----------------------
    The credentials for the next level can be retrieved by submitting the password of the current level to a port on localhost in the range 31000 to 32000. First it must be found out which of these ports have a server listening on them. Then one will have to find out which of those speak SSL and which don’t. There is allegedly only 1 server that will give the next credentials, the others will simply send back to you whatever is sent to them.
    Good thing that nmap is also listed as something useful here. It is a port scanning tool.
        $ nmap -p31000-32000 localhost
    will scan the range of specified ports (the flag "-p" is used to specify which port(s) are to be scanned and then one can specify a single port directly after it, a collection of ports separated by commas or a range of ports with either endpoint of the range separated by a hyphen. The machine to be scanned follows after this).
    The scan gives:
        Starting Nmap 7.80 ( https://nmap.org ) at 2024-02-03 15:22 UTC
        Nmap scan report for localhost (127.0.0.1)
        Host is up (0.00016s latency).
        Not shown: 996 closed ports
        PORT      STATE SERVICE
        31046/tcp open  unknown
        31518/tcp open  unknown
        31691/tcp open  unknown
        31790/tcp open  unknown
        31960/tcp open  unknown

        Nmap done: 1 IP address (1 host up) scanned in 0.09 seconds
    showing that localhost listens on 5 ports (ie. they are "open") for TCP-connections. The service is unknown however. Anyway the ports are numbered and their respective number shows up in this result.
    Now nmap also has a way of finding out what the services being run are. This is done by using the "-sV" flag. However, it tends to send a lot of different types of probes off and all that is wanted is a probe for SSL. Luckily there is a way to control, which types of probes are sent off (sort of). Using "--version-intensity", one can determine how intensive the probing should be. This flag is used with a number in the range 0 to 9 (both endpoints included). The minimum required argument for discovering SSl is "1".So
        $ nmap -sV --version-intensity 1 -p31046,31518,31691,31790,31960 localhost
    should test only the open ports for SSL (along with a few other things). The result is
        Starting Nmap 7.80 ( https://nmap.org ) at 2024-02-03 15:40 UTC
        Nmap scan report for localhost (127.0.0.1)
        Host is up (0.00017s latency).

        PORT      STATE SERVICE     VERSION
        31046/tcp open  echo
        31518/tcp open  ssl/echo
        31691/tcp open  echo
        31790/tcp open  ssl/unknown
        31960/tcp open  echo
        1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :
        SF-Port31790-TCP:V=7.80%T=SSL%I=1%D=2/3%Time=65BE5E83%P=x86_64-pc-linux-gn
        SF:u%r(GenericLines,31,"Wrong!\x20Please\x20enter\x20the\x20correct\x20cur
        SF:rent\x20password\n")%r(GetRequest,31,"Wrong!\x20Please\x20enter\x20the\
        SF:x20correct\x20current\x20password\n")%r(SSLSessionReq,31,"Wrong!\x20Ple
        SF:ase\x20enter\x20the\x20correct\x20current\x20password\n")%r(TLSSessionR
        SF:eq,31,"Wrong!\x20Please\x20enter\x20the\x20correct\x20current\x20passwo
        SF:rd\n");

        Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
        Nmap done: 1 IP address (1 host up) scanned in 32.68 seconds.
    Seems we have a winner at port 31790. Using Openssl to connect and paste in the password to the current level on this port just as in the previous level gives:
        Correct!
        -----BEGIN RSA PRIVATE KEY-----
        MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJ
        imZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQ
        Ja6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTu
        DSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbW
        JGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNX
        x0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvD
        KHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBl
        J9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovd
        d8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nC
        YNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8A
        vLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama
        +TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT
        8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnx
        SatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHd
        HCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+Exdvt
        SghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0A
        R57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDi
        Ttiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCg
        R8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiu
        L8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Ni
        blh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkU
        YOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM
        77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0b
        dxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3
        vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=
        -----END RSA PRIVATE KEY-----

        closed
    which is rather interesting, since this time a password is not sent back, but an RSA key.


Level 17 -> Level 18
-----------------------
    There are 2 files in the homedirectory: passwords.old and passwords.new. The password for the next level is in passwords.new and is the only line that has been changed between passwords.old and passwords.new
    Using the SSH trick from Level 13 -> Level 14 with the private key recovered in the last challenge gives one permission to log into the remote machine on user bandit17. Just as described, inside the home directory there are 2 files, called "passwords.old" and "passwords.new". Both are long. Not long enough that it would be impossible to find the next password manually, but that seems to defeat the purpose of the challenge.
    The "diff" command can be used to compare files line by line. By default it only outputs what is different between the files.
        $ diff passwords.old passwords.new
    gives
        42c42
        < p6ggwdNHncnmCNxuAt0KtKVq185ZU7AW
        ---
        > hga5tuuCLF6fFzUpnagiMN8ssu9LFrdg
    which means that the difference between the contents of the two files are on line 42 and that the password has been changed from
        p6ggwdNHncnmCNxuAt0KtKVq185ZU7AW
    to
        hga5tuuCLF6fFzUpnagiMN8ssu9LFrdg.
    Again things are commented out in the SSH config file, in the same way as earlier.


Level 18 -> Level 19
-----------------------
    A quick note from the previous challenge here: if one has solved Level 17 -> Level 18 and see "Byebye !" when trying to log into bandit18, this is related to the next level, bandit19.
    Anyways this time the password for the next level is stored in a file called "readme" in the home directory. The problem now is that someone has modified the .bashrc file to log one out, when logging in using SSH and that is exactly what happens. "Byebye !" is printed and one is logged out. Anyway the ".bashrc" file is loaded each and every time one opens a terminal - such as logging in through SSH. But SSH is not actually just for logging into a remote machine. It is also used to send commands.
        $ ssh bandit18@bandit.labs.overthewire.org -p 2220 cat readme
    is then the command to be used. This sends the command "cat readme" to the server. One is still prompted for a password, but pasting it in from the results of the previous challenge and hitting Enter then gives:
        awhqfNnAbc1naukrpqDYcF95h7HoMTrC
    before one is once again logged out. This must then be the password for the next challenge.

    What the note from the previous challenge was for, I am not sure of.


Level 19 -> Level 20
-----------------------
    This time there is a setuid binary in the homefolder (a file that can set the user id to the owner of the binary and thus one is able to act as if one is that other user). Executing it without arguments should show how to use it.The password this time is found in the /etc/bandit_pass directory, but one must allegedly use the setuid binary first (probably in order to be able to read it).
    Logging in and using
        $ ls
    reveals a file:
        bandit20-do
    and executing it with
        $ ./bandit20-do
    prints
        Run a command as another user.
            Example: ./bandit20-do id.
    This above example actually gives the output
        uid=11019(bandit19) gid=11019(bandit19) euid=11020(bandit20) groups=11019(bandit19)
    which seems to suggest that the user bandit19 is given an extra user id as bandit20, when making use of the file(?).
    Now
        $ ./bandit20-do ls /etc/bandit_pass
    prints out the contents of the directory /etc/bandit_pass. One of the files is called "bandit20". Guess it is the one wanted, so
        $ ./bandit20-do cat /etc/bandit_pass/bandit20
    prints out
        VxCazJaVykI6W36BkBU0mJTCM8rR95XT
    which must then be the password.


Level 20 -> Level 21
-----------------------
    This time there is another setuid file in the home directory. This one makes a connection to localhost on the port specified (given as a commandline argument) and reads a line of text from the connection, before comparing it to the password from the previous level. If the password is correct, it will then transmit the password for the next level.
        $ ls
    gives
        suconnect.
    This must then be the binary mentioned.
        $ ./suconnect
    prints out
        Usage: ./suconnect <portnumber>
        This program will connect to the given port on localhost using TCP. If it receives the correct password from the other side, the next password is transmitted back.
    Okay so the idea here is that we want to set up a server to run on the machine in the background, that listens for an inbound connection on some port. Once it establishes an incoming connection, it is supposed to send off the password to this level. An ampersand "&" can be used at the end of a command line input to make the command being inputted go into the background and stille be active. Netcat can be used to set up the one time use server that listens for a TCP connection on the port of our choosing. To do this in localhost it has to be done with the "-l" flag. The "-p" flag will specify the port. The password can be pipelined into this server using the "echo" command:
        $ echo VxCazJaVykI6W36BkBU0mJTCM8rR95XT | nc -l -p 1337 &.
    Here I set the port to "1337", so
        $ ./suconnect 1337
    returns
        Read: VxCazJaVykI6W36BkBU0mJTCM8rR95XT
        Password matches, sending next password
        NvEJF7oVjkddltPSrdKEFOllh9V1IBcq
    and the next password is then retrieved as
        NvEJF7oVjkddltPSrdKEFOllh9V1IBcq.


Level 21 -> Level 22
-----------------------
    Allegedly a program is running at regular intervals automatically, using "cron" (a time-based job scheduler). The directory /etc/cron.d/ holds the configuration file. Apparently the command being executed is of interest.
    The directory holds some cron jobs. These are specified per user in files and there is one called "cronjob_bandit22", which must be the one of interest here.
        $ cat cronjob_bandit22
    gives
        @reboot bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null
        * * * * * bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null.
    Apparently cron examines such entries once a minute. It would then seem that the script "/usr/bin/cronjob_bandit22.sh" is run after reboot and each minute(? (the asterisks are used to signify the range of possible values, one for minutes, one for hours, one for days of the month, one for months and one for weekdays)) with the output of the job not printed.
        $ cat /usr/bin/cronjob_bandit22.sh
    gives
        #!/bin/bash
        chmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
        cat /etc/bandit_pass/bandit22 > /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv.
    Okay, it is already known that "/etc/bandit_pass/bandit22" is supposed to hold the password for bandit level 22. It would seem that it is being sent into the file "/tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv". This file should then hold the password.
        $ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
    then gives
        WdDozAdTM2z9DiFEQ2mGlwngMfj4EZff
    which must then be the password to the next level.


Level 22 -> Level 23
-----------------------
    Exactly the same as last time with the program running at regular intervals again.
    In "/etc/cron.d/" there is a file called "cronjob_bandit23".
        $ cat cronjob_bandit23
    prints out
        @reboot bandit23 /usr/bin/cronjob_bandit23.sh  &> /dev/null
        * * * * * bandit23 /usr/bin/cronjob_bandit23.sh  &> /dev/null.
    Much like before some shell script is run each and every minute.
        $ cat /usr/bin/cronjob_bandit23.sh
    gives
        #!/bin/bash

        myname=$(whoami)
        mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)

        echo "Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget"

        cat /etc/bandit_pass/$myname > /tmp/$mytarget.
    It would seem that the name of the user doing the job (which I suppose is "bandit23") is put into a string that is then hashed using the MD5 hashing algorithm (if interested, read about it here: https://en.wikipedia.org/wiki/MD5) and the result of this then has some sections removed based upon a blank space as a delimiter (specified using the "-d" flag) and only the "1" field is then selected (specified by using the "-f" flag followed by "1"). This form the name of the file in the /tmp/ folder where the password is stored.
    Going into the /tmp/ directory and using "ls" gives
        ls: cannot open directory '.': Permission denied.
    That would have been to easy anyways. Doing
        $ echo I am user bandit23 | md5sum | cut -d ' ' -f 1
    however gives
        8ca319486bfbbc3663ea0fbe81326349.
    This must then be the name of the file holding the password.
        $ cat /tmp/8ca319486bfbbc3663ea0fbe81326349
    then gives
        QYw0Y2aiA672PsMmh9puTQuhoz8SyR2G
    which must be the password to the next level.


Level 23 -> Level 24
-----------------------
    
    


        


