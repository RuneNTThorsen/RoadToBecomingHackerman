Level 0:
-----------
    In Bandit0 you are supposed to connect to bandit.labs.overthewire.org using ssh on port 2220. The username is bandit0 and so is the password. Provided one has ssh installed, this is done in the terminal with
        $ ssh bandit0@bandit.labs.overthewire.org -p 2220.
    Notice the flag "-p" and the number "2220". The flag is used to tell ssh that a specific port is to be used and the subsequent number is the port to be used.    
    After this is done, one is asked for the password, which as previously mentioned is "bandit0". Typing this in and hitting Enter then grants access.


Level 0 -> Level 1:
----------------------
    Once in you have to find the password for the next level. That is the password for bandit1. It is allegedly in the file "readme" in the directory that you are in, once bandit0 has been completed. To check this use
        $ ls
    and the file "readme" is listed. Use
        $ cat readme
    to print out the contents of the "readme"-file. The password is then printed out to your terminal. The contents read
        NH2SXQwcBdpmTEzi3bvBHMM9H66vVXjL.

    In general for the bandit levels, level <x> is accessed using
        $ bandit<x>@bandit.labs.overthewire.org -p 2220
    and the password from the previous level.


Level 1 -> Level 2:
----------------------
    Here the password for the next level is in a file called "-".
        $ cat '
    does not work - probably because the filename is a special character. The same goes for
        $ cat "-".
    However, the command
        $ cat ./-
    does work, since the whole path to the file is being specified, yielding the password
        rRGizSaX8Mk1RTb1CNQoXTcYZWU6lgzi.


Level 2 -> Level 3:
----------------------
    The password for level 3 is in a file called "spaces in this filename". Under normal circumstances the Linux terminal cannot handle spaces in a name, since it then assumes that the thing after the space is a new command entirely. The solution is then to put the file name in quotation marks:
        $ cat "spaces in this filename"
    then yields the password
        aBZ0W5EmUfAf7kHTQeOwd8bauFJ2lAiG.


Level 3 -> Level 4:
----------------------
    This time the password is in a hidden file inside the folder "inhere". Usually, one would use
        $ ls
    to list the files in a directory, but using this inside the "inhere" folder yields nothing as expected, since the file that is looked for is a hidden file. Therefore
        $ ls -a
    is used, since the flag "-a" makes ls also list hidden files, which can be recognised by having their filename start with "." (a full stop). (obviously, one would first have to change directory to the aforementioned folder using
        $ cd inhere.
    "cd" is the Linux command used to change directory. It is also a shorthand for exactly that)
    The hidden file that is being looked for is listed and is called ".hidden". Using
        $ cat .hidden
    then prints out the password
        2EW7BBsr6aMMoJ2HjW067dm8EgX26xNe


Level 4 -> Level 5:
----------------------
    The file with the password is again inside a folder called "inhere". Allegedly there is only one human-readable file in this directory, which is also the one that contains the password for the next level. Trying to read the other files in the directory does something weird with the terminal, but this can easily be undone using
        $ reset
    but is not strictly necessary. Through trial and error the file "-file07" seems to be the one that is sought after. Using
        $ cat ./-file07
    then yields the password
        lrIWWI6bB37kxfiCQZqUdOIYfr6eEeqR.


Level 5 -> Level 6:
----------------------
    This time the file containing the password is somewhere inside the folder "inhere" again. Allegedly the file is human-readable, has size 1033 bytes and is not an executable file. Something worth of notice is that the folder "inhere" contains a lot of subfolders called "maybehere00"..."maybehere19".
        $ find . -type f ! -executable -size 1033c
    should find the wanted file in question. The "find" function is the native Linux function that finds a specific file - or at least the ones that matches the parameters that have been specified. "." tells "find" that the search is to start in the current folder, "-type" is a flag that is followed by some parameter that specifies which type of file that is being looked for (in this case "f" for a regular file). "!" is used in order to negate the following expression, "-executable" which specifies that the file in quetion is an executable file (so "! -executable" means that the file in question is not an executable). "-size" is used to specify the size of the file in question and is followed by the parameter "1033c", which specifies that the wanted file is of size 1033 bytes ("c" for bytes).
    The only file that lives up to all the specifications above is the file
        ./maybehere07/.file2,
    so using
        $ cat maybehere07/.file2
    (or if the directory has not been changed since connecting:
        $ cat inhere/maybehere07/.file2)
    then yields the password
        P4L4vucdmLnm8I7Vl7jG1ApGSfjYKqJU.
    (Do however notice, the file contains a lot of whitespace.)


Level 6 -> Level 7:
----------------------
    The only info given about the file containing the password now is that it is stored somewhere on the ssh server, is owned by the user "bandit7", is owned by the group "bandit6" and has size 33 bytes. First of all, let's change directory to the root folder of the server using
        $ cd /.
    Now the command
        $ find . -size 33c -user bandit7 -group bandit6
    can be used and it gives a large and unmanageable list of files, most of which has "Permission denied" written next to them.
    The "-user" flag is given above and is used to specify the user that owns the file being searched for. It is used with the parameter "bandit7", meaning that the file being searched for is owned by the user "bandit7". Likewise the flag "-group" specifies the group that own the file and is used with the parameter "bandit6" to signify, that the group "bandit6" owns the file.
    The problem of making this long list of found files a bit more manageable is done by taking all the files for which permission is denied and sorting them out of the results. The "Permission denied" comes because of a standard error code - more specifically error code 2. By appending "2>dev/null", all results that are returned with standard error code 2 is sent to dev/null (aka. not shown). Thus the file in question is found using
        $ find . -size 33c -user bandit7 -group bandit6 2>/dev/null
    which yields the file
        ./var/lib/dpkg/info/bandit7.password.
    Now
        $ cat var/lib/dpkg/info/bandit7.password
    yields the password
        z7WtoNQU2XfjmMtWA8u5rN4vzqu4v99S.


Level 7 -> Level 8:
----------------------
    This time the password is stored inside the file "data.txt" next to the word "millionth".
        $ cat data.txt
    gives a large and unmanageable list of word and possible passwords next to them. One thing of note is that each and every word- and possible password combination ends with a newline character. This means that what is sought is actually just a specific line in the file.
        $ grep -F millionth data.txt
    can then be used. "grep" is a native Linux command that is used to find a specific line of text in a given file and print it to the terminal. The flag "-F" is used to signify that a specific word is sought (here "word" actually just means a fixed string) and so using it with the parameter "millionth" specifies that the line sought has the word "millionth" in it. As a second argument for grep, the file that is to be searched is specified here; "data.txt". The returned line of text is then
        millionth	TESKZC0XvTetK0S9xNwm25STk5iWrBvP
    from which it can be seen that the password for the next level is
        TESKZC0XvTetK0S9xNwm25STk5iWrBvP.


Levle 8 -> Level 9:
----------------------
    In this level the password is again inside a file called "data.txt". It is stored as the only line in this file that is not repeated.
        $ cat data.txt
    shows that the file contains a lot of lines of potential passwords. Again this is quite unmanageable. The command
        $ uniq -u data.txt
    gives the same output. The "uniq" command is used to filter adjacent matching lines from the input, the "-u" flag specifies that unique lines are to be considered and the second argument is just the file that is to be searched. In order to solve this challenge, the lines need to be read, sorted and then input into "uniq -u". This is done using
        $ cat data.txt | sort | uniq -u.
    "cat" first reads the file, then the lines are sorted using the command "sort" and then the wanted line is found as described above. The vertical lines in this command terminal input is used to take the output of the command on the left and input it into the command on the right. This works because all the lines that are repeated are now adjacent, yielding the line
        EN632PlfYiZbn3PhVK3XOGSlNInNE00t
    which must then be the password that is sought after.


Level 9 -> Level 10:
-----------------------
    The password for this level is again contained in a file called "data.txt". The line with the password is one of the few lines that are human-readable and is preceded by several equal signs. It is of noteworthy importance that the file contains more lines than is feasible to manually search through. Trying
        $ grep === data.txt
    yields
        grep: data.txt: binary file matches,
    so the file is not just a file of text containing several lines, but is a binary file. Here "grep" is used with the first argument of "===", so as to make sure that only lines containing at least 3 equal signs are matched and printed out to the terminal.
        $ strings data.txt
    is the command used to print all ASCII strings in the file, so
        $ string data.txt | grep ===
    is used to take these strings and sent them over to the previously used "grep" command, which should be able to find the line in question. The output is
        x]T========== theG)"
        ========== passwordk^
        ========== is
        ========== G7w8LIi6J3kTb8A7j9LgrywtEUlyyp6s
    and the password can then be read from this as
        G7w8LIi6J3kTb8A7j9LgrywtEUlyyp6s.


Level 10 -> Level 11
-----------------------
    Again the password is inside the file "data.txt", but this time the file is encoded in base 64.
        $ base64 -d data.txt
    is the command to use. "base64" is the command used to do stuff with base 64 numbers, the flag "-d" is used to specify that decoding is wanted and the second argument is just the file that contains what is to be decoded. Using the command above gives
        The password is 6zPeziLdR2RKNdNYFNb6nVCKzphlXHBM
    and so the password is then
        6zPeziLdR2RKNdNYFNb6nVCKzphlXHBM.


Level 11 -> Level 12
-----------------------
    Again the password is inside a file called "data.txt", but this time all of the letters are rotated by 13. This means that the cryptosystem Rot13 has been used (https://en.wikipedia.org/wiki/ROT13) on the letters - which is actually just a special case of the Caesar Cipher using 13 as a key (https://en.wikipedia.org/wiki/Caesar_cipher).
        $ cat data.txt
    gives
        Gur cnffjbeq vf WIAOOSFzMjXXBC0KoSKBbJ8puQm5lIEi.
    Decoding could be done by hand and it is also not hard to implement a small script that could do the decoding. I took the easy route and used an online tool (https://www.dcode.fr/rot-13-cipher) to decode yielding
        The password is JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv
    from which the password can be seen to be
        JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv.

    Okay, I actually did it properly and made a small script that does the decrypting (and encrypting). It is called caesar.py and is used by doing
        python caesar.py "Gur cnffjbeq vf WIAOOSFzMjXXBC0KoSKBbJ8puQm5lIEi" 13 d
    and returns
        The password is JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv.


Level 12 -> Level 13
-----------------------
    The password is once again in a file called "data.txt". This file is a so-called hexdump. It is suggeested that one creates a folder inside of the /tmp folder, copy the file into there and rename it. At each level, some hints are given as to which topics one might look into. One of these is "xxd". This is used to make a hexdump or do the reverse. The "-r" flag is used for reversing. So start by making a directory and moving the file as instructed:
        $ mkdir /tmp/<your-name>
        $ cp data.txt /tmp/<your-name>/data.txt
    and changing to this directory
        $ cd /tmp/<your-name>
    Now let's try reversing and saving whatever gets reversed.
        $ cat data.txt | xxd -r > data
    Another hint is the command "file"; used to determine the file type of a file.
        $ file data
    gives
        data: gzip compressed data, was "data2.bin", last modified: Thu Oct  5 06:19:20 2023, max compression, from Unix, original size modulo 2^32 573.
    Supposing that it is then a ".gz"-file, the file is then renamed as such:
        $ mv data data2.gz
    "gzip" is also a linux command that can be used to compress/decompress files. Decompression is done using the "-d"-flag.
        $ gzip -d data2.gz
    then decompresses and saves the decompressed file as "data2".
        $ file data2
    gives
        data2: bzip2 compressed data, block size = 900k.
    "bzip2" is another file compression/decompression program. The file ending this time is ".bz2".
        $ mv data2 data3.bz2
        $ bzip2 -d data3.bz2
    then gives the file
        data3.
    Using
        $ file data3
    gives
        data3: gzip compressed data, was "data4.bin", last modified: Thu Oct  5 06:19:20 2023, max compression, from Unix, original size modulo 2^32 20480
    and so we repeat the process for a gzip archive again.
        $ file data4
    now gives
        data4: POSIX tar archive (GNU).
    "tar" is another linux command used to make archives.
        $ tar -xvf data5
    then makes the file "data5.bin". The flags "x", "v" and "f" specifies extraction, verbose and file respectively. This is then renamed to "data6.bin" and this file gives the same output again, so unpacking is done again. It seems that renaming and unpacking and seeng what the file contents are has to be done a few times. I have already shown how the tools used. Unless something new comes up, I will just state here, that decompressing and unpacking is done until i reach the end.
    Finally after going through the steps over and over, a "data9" is reached, that is ASCII text.
        $ cat data9
    then gives
        The password is wbWdlBxEir4CaE8LaPhauuOo6pwRmrDw
    from which it can be seen that the password is
        wbWdlBxEir4CaE8LaPhauuOo6pwRmrDw.

    It was suggested to me, that binwalk might have been able to do this task more easily. Perhaps. I think learning about tar, bzip2 and gzip is good though and I doubt, I would have permission to install binwalk on the machine that I am connected to through ssh. The contents of the original data might be copied to my own machine though, but this is not a route that I will explore.



Level 13 -> Level 14
-----------------------
    The password for the next level is stored in /etc/bandit_pass/bandit14. It can only be read by the user bandit14 though. As for this level, one does not get a new password, but instead a private ssh-key (in the home folder - called "sshkey.private"), which will be used to log in to the next level. A hint is given: localhost is a hostname that refers to the machine you are working on.
        $ ls
    gives
        sshkey.private.
        $ cat sshkey.private
    then prints out the ssh-key. It is an RSA key. That is pretty standard. It is then copied into a file "bandit14" in the ~/.ssh directory. In this directory there is also a "config"-file. The key has to be added to this.The following then has to be added to this file:
        Host *.labs.overthewire.org
            user bandit14
            IdentityFile ~/.ssh/bandit14
    and ownership has to be taken of the file:
        $ chown 600 ~/bandit14
    and the key can now be used to log in to the bandit 14 user (the terminal program maybe has to be restarted).
        $ cat /etc/bandit_pass/bandit14
    now gives
        fGrHPx402xGC7U7rXKDaxiWFTOiF0ENq
    which must then be the password for the next level.
    The changes made to the config file can then be commented out using "#":
        #Host *.labs.overthewire.org
            #user bandit14
            #IdentityFile ~/.ssh/bandit14
    and they shouldn't be used in the future then.


Level 14 -> Level 15
-----------------------
    The password for the next level can be retrieved by submitting the password of the current level to port 30000 on localhost.
        


