FE put up an ad on Facebook in which they ask, if one has what it takes to solve a crypto challenge.

The encryption program used is included here in the file "cipher.py", which is a Python2 program (this will become important).

First up, the cipher uses a password to generate a keystream that is xor’ed into each byte of the original content in order to produce the ciphertext. The same password can be used to generate the same keystream later in order to xor this into the ciphertext to get the original content back again (remember that xor is it’s own inverse). This tells us 3 things; firstly the cipher is completely deterministic, secondly the cipher is a stream cipher and thirdly the cipher is a symmetric cipher. The keystream depends on some initial values that are generated by hashing the password using MD5. Specifically 4 bytes of the digest are used as an initialisation vector. As for the password itself, if it is less than or equal to 4 in length, then the encrypted file will have ”LOW”in the start of its contents (before the actual encrypted content). If it is of length 5 or 6, it will start with ”MED”and if it is above 6, then it will start with ”HIG”. 2 of the files starts with ”HIG”and one starts with ”LOW”. The code dictates that the password can only consist of alphanumeric symbols, so bruteforcing the file that starts with ”LOW”might be feasible, but if there exists a way to decrypt the other two, then there must surely also exist such a way to decrypt this file. Bruteforcing the short password can however be kept in the back of my head. As can bruteforcing the initialisation vector. One thing about the keystream generation worth mentioning is that it comes from linear shift feedback registers. Specifically 3 of them. These are the ones that are initialised using the previously mentioned 4 bytes from the digest of the password. There seems to be no additional nonlinear operations in place. One thing that I think would be useful for checking whether or not a bruteforced password or key was correct was the fact that the cipher makes the ciphertext start with an encrypted version of the string ”LSFR”.

A bruteforcer that bruteforces the password used for the encryption is found in the program called "pswdbrute.py". This is also written in Python2. It only finds the password used for encryption and is supposed to only be used, if the start of the encrypted filed is "LOW". Maybe it can be used for files starting with "MED" (by chaning the value in the range on line 76), but it would probably take too long. As for files starting with "HIG", there is no guarantee of a set length of a password, other than it being longer than 6 characters long. So it would not make sense to try to brute force such a password.
One thing to note here though is that the initialiation is done using MD5, which is famous for having collisions, so it might be worth it to try breaking "MED" or "HIG" passwords using this program anyway.

I attached yet another program called "bruteforcer.py". This tries to bruteforce the initialisation vector used in the encryption. It runs into an error when finding the right initialisation vector, but is also slow, so it needs to be optimized. I know how to do that, but have not done it yet.

Let me just share some thought about how the challenge might be solved once and for all, making a full circle around the problem and its potential solutions.

Knowing that the first 4 bytes (32 bits) of the cipher is supposed to decrypt into ”LSFR”and knowing that Python2 chooses to have its string be bytes corresponding to the ASCII encoding of characters by deafult and only doing it in other formats when necessary, the first 4 bytes of the plaintext becomes known (assuming that the encoding did not change when appending the rest of the plaintext). I wondered if there was a way to exploit this knowledge of the initial 4 bytes in order to do something to decrypt the rest of the ciphertext. Searching online, I found my answer. The Berlekamp-Massey algorithm is apparently an algorithm that can take such a keystream and give the shortest LSFR that can produce it. More generally it actually finds the minimal polynomial of some linearly recurrent sequence of numbers in some arbitrary field (a so-called feedback polynomial ). We are dealing with binary numbers (actually bits) here, so we are dealing with the Galois Field GF(2) (this basically just means that all arithmetic operations will have to be done modulo 2). As an example; if the algorithm finds a polynomial for us that looks like T^8 + T^7 + T^5 + T^4 + T^3 + T^2 + T + 1, then the found LSFR has length 8 and has feedback taps set on 1, 2, 3, 4, 5, 7 and 8. As far as I can tell (from the Wikipedia page and the original paper) this works because the entropy of the first bits of such a keystream originating from an LSFR is somewhat high, but the more initial bits known, the less the entropy of any subsequent bits. This also leads to the fact that this way of going forward will only work if the minimum LSFR that produces the keystream has length n at most 32/2. Since there are 3 registers used however, then the period of the resulting LSFR used in the cipher is equal to the least common multiple of the periods of each of the 3 LSFR’s. Since the maximum period of an LSFR depends on its length, then the hope is that the LSFR’s have been initialised with some value that produces a not too big period or are constructed in such a way to make a period that is small (this also means that this method will not work in the general case, but is still worth checking out). I found an online repository with an implementation of the algorithm here: https://github.com/thewhiteninja/lfsr-berlekamp-massey but it does not work in the general case!

As for files encrypted with a password, that is prepended by "LOW" remember as well that this means that the password used has length at most 4. This gives a total of 15,018,570 possibilities for a choice of a given password being used to do the encryption. That is a lot less than the 4,294,967,296 possibilities of the 4 bytes used as the key. The password of this file can then maybe be bruteforced. The file "pswdbrute.py" contains the code that was tried in order to brute force the weak password. A quick performance run revealed that it could possibly do the job in a reasonable amount of time. The program can be run with

    python2.7 file1.enc file1.clr

It prints out the potential passwords, that it has found. The speed of the password bruteforcer is achieved by only continuing, if testing shows that the first 4 bytes actually decrypts to "LSFR".

As for files encrypted with a password that is longer, the best way to go is to bruteforce the "n" used in the initialisation step. The trick here is to realise, that it is not the whole MD5 hash, that is used during the initialisation. Limiting the amount of bits that one tries to bruteforce and using the trick with checking hat the first 4 bytes should decrypt to should achieve the goal of decryption in a reasonable amount of time. Otherwise, on might check the individual bits, in order to save even more time.
